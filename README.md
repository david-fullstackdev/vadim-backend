# tbd_solutions_server

# TBD Platform Web Server

**Requirements**

- Node => 8.0.0
- Postgres (9.*)

### Installation

1) `yarn` to install dependencies
2) `createdb tbd && createdb tbdtest` to create relevant databases
3) `cp .env.example .env` to initialize your `.env` file
3) `yarn dev` to run development environment
4) `yarn seed` to generate seed data

### Development notes
1) `yarn create-migration migration_name` to create new migration file  
2) `yarn migrations` to migrate db to the latest migration  
3) `yarn rollback-migration` to rollback last migration  
4) `yarn reset-db` to recreate db with migrations and generate seed data  
5) `yarn reset-test-db` is the same as 4) just for test db   

### Testing

Each main schema type, has an associated spec to define related tests. (ie `/routes/brand/schema.spec.js`). This spec contains a test for each of the query types associated with this schema type. Any common selection sets can be pulled out and imported from `/routes/lib/test-fragments`.

The tests can be run with `yarn test`. This will run each file concurrently, while each test within a given file is run sequentially. Each test will have a database transaction created before it and rolled back after the test has executed, ensuring that tests shouldn't impact each other with mutations etc.

You will need to create a database once which is used exclusively for test automation, with `createdb tbdtest`. Keeping the test database separate from your own local test database ensures your manual testing remains isolated.

Each test will have a snapshot which is autogenerated the first time it is run, and is used to verify the test output for consequent runs. These snapshots should be committed to source control. If there is a difference in a snapshot, or an error in a query used in a test, the test will fail with relevant information provided. If a snapshot has become outdated, when it fails you can update them with `yarn test -- -u`.

You can isolate the test run to a single file by passing the file, or containing directory, as a parameter (ie `yarn test routes/brand`).

You can isolate a single test within a spec file by adding `.only` after the test function call (ie `test.only('some test', () => ...)`).

In theory, jest supports running tests within a file concurrently, by adding '.concurrent', but this will not work for our tests that hit the database as a test file's transaction object reference is re-used among tests.
